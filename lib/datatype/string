#!/bin/bash


################################################################################
#                                         
# |              |    |         |         
# |---.,---.,---.|---.|    ,---.|--- ,---.
# |   |,---|`---.|   ||    |---'|    `---.
# `---'`---^`---'`   '`---'`---'`---'`---'
#
#                                        
# Bashlets -- A modular extensible toolbox for Bash
#
# Copyright (c) 2014-8 Roberto Reale
# 
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#
################################################################################


source bashlet charstream/reorder
source bashlet charstream/reshape
source bashlet os/random

#@method
function bashlets_datatype_string_chop()
{
    echo "$(echo "$@" | tr -d "\n")"
}

#@method
function bashlets_datatype_string_length()
{
    local str="$*"
    echo ${#str}
}

#@method
function bashlets_datatype_string_index()
{
    # cf. https://github.com/marcomaggi/mbfl/blob/master/src/modules/string.sh.m4
    local haystack="$1"
    local needle="$2"
    local start="${3:-0}"
    local i

    for ((i=$start; $i < ${#haystack}; ++i))
    do
        test "${haystack:$i:1}" = "$needle" && {
            echo "$i"
            return 0
        }
    done
}

#@method
function bashlets_datatype_string_upper()
{
    echo "$*" | tr a-z A-Z
}

#@method
function bashlets_datatype_string_lower()
{
    echo "$*" | tr A-Z a-z
}

#@method
function bashlets_datatype_string_to_integer()
{
    printf "%d\n" "$1"  # removes leading zero's
}

#@method
function bashlets_datatype_string_to_bool()
{
    local value="$(bashlets_datatype_string_lower "$*")"
    local try

    [[ -n $value ]] || return 1

    for try in y yes true 1
    do
        [[ $value == $try ]] && return
    done

    return 1
}

#@method
function bashlets_datatype_string_urlencode()
{
    # TODO requires perl
    # cf. https://www.if-not-true-then-false.com/2009/google-search-from-linux-and-unix-command-line/
    echo -n $@ | perl -pe's/([^-_.~A-Za-z0-9])/sprintf("%%%02X", ord($1))/seg'
}

#@method
function bashlets_datatype_string_bin_to_dec()
{
    ########################################################################
    #
    # Code borrowed from: text_convert.sh by Luciano D. Cerere
    #
    # cf. https://gist.github.com/ldante86/679c2240acd7cc838e1d6fcac97dc4d3
    #
    ########################################################################

	local bin=$1
	local i jump=1 dec=0

	for ((i=${#bin}; i>0; i--))
	do
		case ${bin:i-1:1} in
			1) ((dec+=jump)) ;;
		esac
		((jump*=2))
	done

	echo $dec
}

#@method
function bashlets_datatype_string_dec_to_hex()
{
    ########################################################################
    #
    # Code borrowed from: text_convert.sh by Luciano D. Cerere
    #
    # cf. https://gist.github.com/ldante86/679c2240acd7cc838e1d6fcac97dc4d3
    #
    ########################################################################

    declare -a base16=( {0..10} {A..F} )

	local dec="$1" digit size hex

	[ -z "$dec" ] && return 1

	while (( dec != 0 ))
	do
		((digit=dec % 16))
		if (( digit >= 10 ))
		then
			hex=${base16[digit+1]}${hex}
		else
			hex=${base16[digit]}${hex}
		fi
		((dec/=16))
	done

	echo $hex
}


BASHLETS_DATATYPE_STRING_ENCODE_BASE64_NEWLINE=0

#@method
function bashlets_datatype_string_encode_base64()
{
    ########################################################################
    #
    # Code borrowed from: text_convert.sh by Luciano D. Cerere
    #
    # cf. https://gist.github.com/ldante86/679c2240acd7cc838e1d6fcac97dc4d3
    #
    ########################################################################

    declare -a base64=( {A..Z} {a..z} {0..9} + / )

	local str i block lastblock

	str=$(bashlets_datatype_string_ascii_to_bin "$@")
	[ -z "$str" ] && return 1

	for (( i=0; i<${#str}; ((i+=6)) ))
	do
		block="${str:i:6}"
		if (( ${#block} < 5 ))
		then
			lastblock=${#block}
		fi

		while (( ${#block} < 6 ))
		do
			block="${block}0"
		done

		echo -n "${base64[ $(bashlets_datatype_string_bin_to_dec ${block}) ]}"
	done

	case $lastblock in
		4)	((lastblock -= 2)) ;;
		*)	((lastblock -= 1)) ;;
	esac

	case $BASHLETS_DATATYPE_STRING_ENCODE_BASE64_NEWLINE in
		0)
			case $lastblock in
				1)	echo "o=" ;;
				2)	echo "K" ;;
				*)	echo "Cg==" ;;
			esac
			;;
		1)
			case $lastblock in
				1)	echo "==" ;;
				2)	echo "=" ;;
				*)	echo  ;;
			esac
			;;
	esac
}

#@method
function bashlets_datatype_string_rotate()
{
    ########################################################################
    #
    # Code borrowed from:
    #
    # rot - rotate the alphabet and encode a string
    # cf. https://gist.github.com/ldante86/bbb0f3e69aa61a90710d52a9928487cb
    #
    # Copyright (C) 2014 Luciano D. Cecere <ldante86@aol.com>
    #
    # This program is free software: you can redistribute it and/or modify
    # it under the terms of the GNU General Public License as published by
    # the Free Software Foundation, either version 3 of the License, or
    # (at your option) any later version.
    #
    # This program is distributed in the hope that it will be useful,
    # but WITHOUT ANY WARRANTY; without even the implied warranty of
    # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    # GNU General Public License for more details.
    #
    # You should have received a copy of the GNU General Public License
    # along with this program.  If not, see <http://www.gnu.org/licenses/>.
    #
    #########################################################################

    local rot="$1" ; shift

    [[ $# -eq 0 ]] && return

    case $rot in
        0 )  echo "$input" ;; # no rotation
        1 )  tr 'A-Za-z' 'B-ZA-Ab-za-a' <<< "$@" ;;
        2 )  tr 'A-Za-z' 'C-ZA-Bc-za-b' <<< "$@" ;;
        3 )  tr 'A-Za-z' 'D-ZA-Cd-za-c' <<< "$@" ;;
        4 )  tr 'A-Za-z' 'E-ZA-De-za-d' <<< "$@" ;;
        5 )  tr 'A-Za-z' 'F-ZA-Ef-za-e' <<< "$@" ;;
        6 )  tr 'A-Za-z' 'G-ZA-Fg-za-f' <<< "$@" ;;
        7 )  tr 'A-Za-z' 'H-ZA-Gh-za-g' <<< "$@" ;;
        8 )  tr 'A-Za-z' 'I-ZA-Hi-za-h' <<< "$@" ;;
        9 )  tr 'A-Za-z' 'J-ZA-Ij-za-i' <<< "$@" ;;
        10)  tr 'A-Za-z' 'K-ZA-Jk-za-j' <<< "$@" ;;
        11)  tr 'A-Za-z' 'L-ZA-Kl-za-k' <<< "$@" ;;
        12)  tr 'A-Za-z' 'M-ZA-Lm-za-l' <<< "$@" ;;
        13)  tr 'A-Za-z' 'N-ZA-Mn-za-m' <<< "$@" ;; # rot13
        14)  tr 'A-Za-z' 'O-ZA-No-za-n' <<< "$@" ;;
        15)  tr 'A-Za-z' 'P-ZA-Op-za-o' <<< "$@" ;;
        16)  tr 'A-Za-z' 'Q-ZA-Pq-za-p' <<< "$@" ;;
        17)  tr 'A-Za-z' 'R-ZA-Qr-za-s' <<< "$@" ;;
        18)  tr 'A-Za-z' 'S-ZA-Rs-za-r' <<< "$@" ;;
        19)  tr 'A-Za-z' 'T-ZA-St-za-s' <<< "$@" ;;
        20)  tr 'A-Za-z' 'U-ZA-Tu-za-t' <<< "$@" ;;
        21)  tr 'A-Za-z' 'V-ZA-Uv-za-u' <<< "$@" ;;
        22)  tr 'A-Za-z' 'W-ZA-Vw-za-v' <<< "$@" ;;
        23)  tr 'A-Za-z' 'X-ZA-Wx-za-w' <<< "$@" ;;
        24)  tr 'A-Za-z' 'Y-ZA-Xy-za-x' <<< "$@" ;;
        25)  tr 'A-Za-z' 'Z-ZA-Yz-za-y' <<< "$@" ;;
        * )  return 1 ;;
    esac
}

#@method
function bashlets_datatype_string_rot13()
{
    bashlets_datatype_string_rotate 13 "$@"
}

#@method
function bashlets_datatype_string_to_charstream()
{
    local chr
    echo -n "$*" | while read -r -n1 chr; do echo "$chr"; done
}

#@method
function bashlets_datatype_string_to_matrix()
{
    declare -i cols=${1:-1} chr
    shift
    ((cols > 0)) || return 1
    echo -n "$*" | xargs -n $cols
}

#@method
function bashlets_datatype_string_reverse()
{
    # cf. http://stackoverflow.com/questions/11461625/
    local str="$*"
    local rev

    for ((i=${#str}-1 ; i >= 0 ; i--))
    do
        rev="$rev${str:$i:1}"
    done

    echo "$rev"
}

#@method
function bashlets_datatype_string_transpose()
{
    bashlets_datatype_string_to_charstream "$*"
}

#@method
function bashlets_datatype_string_shuffle()
{
    local str="$*"

    [[ -n $str ]] || return

    bashlets_datatype_string_to_charstream "$str"    \
        | $BASHLETS_NAMESPACE reorder shuffle        \
        | $BASHLETS_NAMESPACE reshape transpose
}


#
# if $* has length 2^n, return the central 2^(n-1) characters;
# otherwise, return nothing
#

#@method
function bashlets_datatype_string_middle_2n()
{
    local str="$*"
    local len=${#str}

    local c2="$((len/2))"
    local c4="$((len/4))"

    echo "$str" | sed -n "s/^.\{$c4\}\(.\{$c2\}\).\{$c4\}$/\1/p"
}


#
# left-pad a given string with PAD, so that its length is rounded up
# to the next multiple of N
#

#@method
function bashlets_datatype_string_lalign_n()
{
    local n="$1"
    local pad="$2"
    shift 2
    local str="$*"
    local len=${#str}

    local q="$((len/n))"
    local r="$((len%n))"

    [[ $r -eq 0 ]] || r=n

    len="$((n*q+r))"

    printf "%0${len}s" "$str" | tr " " "$pad"
}


#@method
function bashlets_datatype_string_generate_random()
{
    local size="${1:-16}"

    $BASHLETS_NAMESPACE random get_stream "$size" [[:print:]]
}


# Local variables:
# mode: shell-script
# sh-basic-offset: 4
# sh-indent-comment: t
# indent-tabs-mode: nil
# End:
# ex: ts=4 sw=4 et filetype=sh
